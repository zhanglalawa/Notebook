# 类加载入门

标签（空格分隔）： 未分类

---

## 类加载机制
JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成JVM可以直接使用的Java类型文件的过程。

 - **加载**：将class文件字节码内容加载到内存中，并将这些静态数据（这个类的静态变量、静态方法、常量迟以及类的代码等等）转换成方法区中的运行时数据结构，接着同时在堆中生成一个代表这个类的java.lang.Class对象（就是反射的那个对象，我们的反射技术就是利用这个类才进入方法区的）作为方法区数据的访问入口，这个过程需要**类加载器**参与。
```graphLR
    A[源] -->B[字节码]
    B --> C{类加载器}
    C --> D(方法区二进制数据和堆中Class对象)
```

- **链接** 将Java类的二进制代码合并到JVM的运行状态之中
  - 验证：确保加载的类信息符合JVM规范，没有安全方面的问题。 
  - 准备：正式为类变量(static变量)分配内存并**设置类变量初始值为默认值**的阶段，这些内存都将在方法区中进行分配 
  public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。
  - 解析：虚拟机常量池内的符号引用替换为直接引用的过程 
- **初始化**
    -  初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集 **类中的所有类变量（static变量）的赋值动作和静态语句块(static块)中的语句**合并产生的。 
    -  当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
    -  虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。
## 初始化的时机
- 类的主动引用（一定会发生类的初始化） 
    - new一个类的对象 
    - 调用类的静态成员(除了final常量)和静态方法 
    - 使用java.lang.reflect包的方法对类进行反射调用 
    - 当虚拟机启动，java  Hello，则一定会初始化Hello类。说白了就是先启动main方法所在的类 
    - 当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类
- 类的被动引用(不会发生类的初始化) 
    - 当访问一个静态域时，只有真正声明这个域的类才会被初始化 
    - 通过子类引用父类的静态变量，不会导致子类初始化 
    - 通过数组定义类引用，不会触发此类的初始化 
    - 引用常量（static final）不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）

参考文章：1.[深入理解类加载][1] 2.[类加载机制][2]
           


  [1]: http://www.cnblogs.com/javaee6/p/3714716.html?utm_source=tuicool&utm_medium=referral
  [2]: https://blog.csdn.net/fgets/article/details/52934178