# 对象收集器和内存分配策略

标签（空格分隔）： JavaGC

---

## **概述**
Garbage Collection需要考虑三件事情：

 - 哪些内存需要回收？
 - 何时回收？
 - 如何回收？

第一个问题我们需要回顾一下上一章里面的内存区域。其中程序计数器、Java虚拟机栈和本地方法栈3个区域随线程生死，栈中的栈帧随着方法的进入和退出执行出栈和入栈操作，每个栈帧分配多少内存也是在类结构确定下来就已知了。所以这些区域的内存分配和回收都具有确定性，方法结束或者线程结束之后，内存就自然跟着回收了。而Java堆和方法区就不一样。一个接口的多个实现类需要的内存可能就不一样，一个方法的多个分支需要的内存也可能不一样，只有在运行时才能知道创建了哪些对象，这部分是动态的分配和回收内存，GC需要关注的就是这块内存。
第二个问题和第三个问题我们接下来将会展开说明。
## **对象已死？**
堆里面存放了几乎所有的实例对象，要确定何时回收，就是判断这个对象是不是还“活着”，哪些已经“死了”就需要被GC，所谓死掉的对象就是指不可能再有任何途径可以让我们使用的对象。常见的场景就是

    Student stu = new Student();
    stu = null;

第一行New出来一个对象，这个实例在堆里面，第二行直接将对象引用置空，这个对象引用不再指向堆里面刚刚生成的对象，程序中也没有其他引用能够指向这个对象，所以我们没有任何方法再去使用这个对象实例，这时候就说这个对象已死，GC的目标就是这样的死掉的对象。
而如何判断这个对象是否死去则有很多方法。
### 一、引用计数法
给对象添加**引用计数器**，当有地方引用它时就加1，引用失效就减1，为0时就认为对象不再被使用可回收。该算法失效简单，判断高效，但并不被主流虚拟机采用，主要原因是它很难解决对象之间相互循环引用的问题。
且看下面的例子：
```java
public static void main(String[] args) {
        GcObject obj1 = new GcObject(); //obj1引用GcObject实例1 Count1 = 0 + 1 = 1
        GcObject obj2 = new GcObject();//obj2引用GcObject实例2  Count2 = 0 + 1 = 1
        obj1.instance = obj2;//obj1.instance引用GcObject实例2   Count2 = 1 + 1 = 2
        obj2.instance = obj1;//obj2.instance引用GcObject实例1   Count1 = 1 + 1 = 2
        
        //需要注意的是instance这里是属于GcObject类的实例数据
        //它不是局部变量，所以不在栈里面，而是在堆中实例对象的内存区域里面
        obj1 = null; //obj1置空不再指向GcObject实例1  Count1 = 2 - 1 = 1 
        obj2 = null; //obj2置空不再指向GcObject实例2  Count2 = 2 - 1 = 1
    }

```
第一步:GcObject实例1被obj1引用,所以它的引用数+1,为1
第二步:GcObject实例2被obj2引用,所以它的引用数+1,为1
第三步:obj1的instance属性指向obj2,而obj2指向GcObject实例2,故GcObject实例2引用+1,为2
第四步:obj2的instance属性指向obj1,而obj1指向GcOjbect实例1,故GcObject实例1引用+1,为2
网上找了张图，很清楚的描述了现在的内存状况：
![此处输入图片的描述][1]
第五步:obj1不再指向GcOjbect实例1,其引用计数减1,结果为1.
第六步:obj2不再指向GcOjbect实例2,其引用计数减1,结果为1.

最后呢，我们发现没有任何途径再能对GcObject的两个实例进行操作，我们能拿到的引用都没有指向他们的。但是呢Count1和Count2并不是0，此时发生GC，并不能把这两个对象回收！
### 二、可达性分析算法
主流实现都是使用可达性分析算法，通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），如果一个对象到GC Roots没有引用链相连，则该对象是不可用的。
![可达性分析算法][2]
可以作为GC Roots对象的以下几种：

>  - 虚拟机栈（栈帧的本地变量表）中引用的对象
>  - 方法去中类静态属性引用的对象
>  - 方法区中常量引用的对象
>  - 本地方法栈中Native方法引用的对象

### 三、再谈引用
判断对象是否存活都与引用有关，JDK1.2以前，Java对于引用的定义是这样的：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，则称这块内存代表着一个引用。这种定义下，一个对象只有被引用和没有被引用两种状态，对于描述一些特殊的“食之无味弃之可惜”的对象无能为力，举个例子：有一种这样的对象，当内存空间足够时，我们希望它保留在内存中，而内存空间在GC之后还是很紧张，我们希望这些对象被GC机制回收。而实际场景中，很多系统的缓存功能都具有这样的特性。
JDK1.2之后就扩充了引用的概念，引入了强软弱虚四种引用，引用强度依次减弱：

>  1. **强引用（Strong Reference)**:类似“Object obj = new Object()”这样的引用，只要强引用存在，被引用的对象就不会被GC；
>  2. **软引用（Soft Reference)**:用来描述一些**有用但是非必须**的对象，如果GC了，内存还是很紧张，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收，如果这次回收之后还没有足够内存，才会抛出内存溢出异常，JDK1.2之后提供了SoftReference来实现软引用；
>  3. **弱引用（Weak Reference)**:也是描述**非必须**对象，强度弱于软引用。软引用关联的对象只能生存到下一次GC发生之前，当垃圾收集器工作时候，无论内存是否足够，都会回收只被弱引用关联的对象。JDK1.2之后提供了WeakReference来实现弱引用；
>  4. **虚引用（Phantom Reference)**:最弱的引用关系，一个对象是否有序引用关联完全不影响其生存时间，也无法通过虚引用来取得一个对象实例。为一个对象设置一个虚引用关联的唯一目的是能在这个对象呗GC时候收到一个系统通知。使用PhantomReference来实现虚引用。

### 四、生存还是死亡
如果可达性分析的结果是没有GC Roots，那么这个对象是不是就可以上刑场了呢？Java说再给它一次机会吧！
在Object类中还有一个方法**finalize()**,这个方法是这个将死对象救赎自己的最后机会。
要真正宣告一个对象死亡需要经过两次标记过程：首先如果发现对象在可达性分析之后发现没有GCRoots，对它进行**第一次标记**，并且进入筛选，筛选的条件是这个对象**有没有必要执行finalize()方法**，如果对象没有覆盖finalize()方法，或者finalize()方法已经被JVM调用过，那么就判定“没有必要执行finalize方法”。没有必要执行finalize方法的对象会被直接回收。
如果有必要执行finalize()方法，这个对象就会被放置在**F-Queue**队列之中，并在稍后由一个由虚拟机自动建立的低优先级的Finalizer线程去执行它。这里的“执行”是让虚拟机去触发这个方法，并不确保等待finalize()方法执行结束，这是因为如果去等待，一个对象在finalize()方法中执行缓慢，（更极端一点处在死循环当中），这可能会让会让F-Queue队列的其他对象永久处于等待状态，甚至让整个GC系统崩溃。finalize()方法是对象逃脱死亡的最后一次机会，拯救自己的方式无非是在finalize方法中，把自己（this关键字）和引用链上任意一个对象建立关联即可。finalize方法之后GC将对F-Queue中的对象进行**第二次标记**，如果它在finalize中自救了，那么第二次标记时候这个对象就会被溢出“即将回收”的集合，如果还没有逃脱，那么就可以认为它的旅程结束了。
下面是一个重写finalize()方法在GC时自救的例子：
```java
public class FinalizaEscapeGC {
    public static FinalizaEscapeGC SAVE_HOKE = null;
    
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method execute ! ");
        FinalizaEscapeGC.SAVE_HOKE = this;
    }
    
    public static void main(String[] args) throws InterruptedException {
        SAVE_HOKE = new FinalizaEscapeGC();
        
        SAVE_HOKE = null;
        System.gc();    //通知gc
        Thread.sleep(500);
        //由于finalize方法优先级很低，所以暂停0.5S等待它，下面也是一样
        if(SAVE_HOKE != null){
            System.out.println("yes,i am still alive !");
        }else{
            System.out.println("no,i am dead !");
        }
        
        SAVE_HOKE = null;
        System.gc();
        Thread.sleep(500);
        if(SAVE_HOKE != null){
            System.out.println("yes,i am still alive !");
        }else{
            System.out.println("no,i am dead !");
        }
    }
}

```
输出结果：

> finalize method execute ! 
yes,i am still alive ! 
no,i am dead !

三行输出说明了很多问题，第一行是finalize方法执行了。第二行说明对象第一次成功拯救了自己，第三行说明一模一样的代码，但是finalize不会再执行第二次了，不存在让它再次拯救自己的机会了。
上面只是一个演示，实际情况我们不常使用finalize的方法来拯救对象，这个方法的运行代价高昂，不确定性大，更建议使用try-finally或者其他方式，可以做得更好！
### 五、回收方法区
上一章提到，方法区的GC涉及两方面：

>  - 常量池的回收（废弃常量）
>  - 类型的卸载（无用的类）

而这两方面GC要求的条件都是比较苛刻的，GC的效率特别低。在堆中常规进行一次GC的收集效率大约在70%~90%之间，而方法区所谓永久代的手机效率远远低于此。
下面重点看一下所谓条件苛刻究竟苛刻在哪里。

 - 常量的废弃的判断标准还是较为简单的，和堆中的对象类似，以字符串为例，如果没有字符串引用指向这个字符串常量，如果发生GC吗，且有必要的话，就认为这个常量是要被回收的，会被清理出常量池。常量池中的其他类、方法、接口、字段的符号引用也是类似的清理规则。
 - 而类的无用判断则条件十分苛刻，需要满足三个条件才算作无用的类：
    

> - 该类所有实例都被回收
> - 加载这个类的ClassLoader已被回收
> - 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

而且，只是JVM“可以”对这样的无用的类进行回收，但也不一定会回收，还有有很多控制的细节，嗯。。看不懂的细节，暂时先不记录了。
## **垃圾收集算法**
### 分代收集算法

根据对象存活周期的不同，将Java堆划分为新生代和老年代，并根据各个年代的特点采用最适当的收集算法。

>  - 新生代：每次GC都会发现大批对象死去，只有少量存活。使用『复制算法』，只需复制少量存活对象即可。
>    
>  - 老年代：对象存活率高。使用『标记—清理算法』或者『标记—整理算法』，只需标记较少的回收对象即可。 

是当前商业虚拟机都采用的一种算法。下面依次介绍上面提到的三种算法。

### 标记-清除算法（Mark-Sweep)
标记出所有要回收的对象，标记完成后统一回收。
![标记清楚算法示意图][3]
过程在前一节的两次标记我们已经讲过了。这是最基础的算法，后续的收集算法都基于这种思路并对其不足进行改进。那么它有什么不足呢？

>  1. 效率低下，标记和清楚的效率都不高
>  2. 空间问题，GC之后会产生大量不连续的内存碎片，这对我们之后的内存分配工作是及其不利的。因为可能没有足够大的一块空地留给一些较大的对象了，到时候又不得不提前触发一次GC，影响系统性能。

所以它适合存活率不高的老年代的GC，只需要做少部分的标记。
### 标记-整理算法（Mark-Compact）
这也是根据老年代的特点提出的算法,标记过程和标记-清楚算法一样，但是后续步骤是让所有存存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
![标记-整理算法][4]
### 复制算法
它解决了效率问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块用完之后，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。
![复制算法的图示][5]
这样做使得每次都是对**整个半区进行GC**，之后的内存分配中也不会遇到所谓内存碎片的问题。只要一动堆顶的指针，按顺序分配内存就可以了。但是也有一个明显的问题是，**牺牲了整整一半的存储空间**！
结合新生代98%“朝生夕死”的特点，并不需要按照1：1去划分新生代内存空间，所以浪费的会少一些。但是这个98%并不是每次都这么理想，我们没有办法保证不出现极端情况，所以还需要依赖其他内存（老年代）进行**分配担保**


  [1]: https://images2015.cnblogs.com/blog/647994/201702/647994-20170218225201894-1235824981.png
  [2]: https://upload-images.jianshu.io/upload_images/3709321-0723ec51621c75f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp
  [3]: https://upload-images.jianshu.io/upload_images/5494434-42f0ef6c40da1489.png?imageMogr2/auto-orient/
  [4]: https://upload-images.jianshu.io/upload_images/5494434-74dd042aa9d81422.png?imageMogr2/auto-orient/
  [5]: https://upload-images.jianshu.io/upload_images/5494434-dfb7d5ecfbfefbbb.png?imageMogr2/auto-orient/