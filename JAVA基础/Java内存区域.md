# Java内存区域

标签（空格分隔）： Java内存区域     

---
## **运行时数据区域**

虚拟机在执行程序时候会把管理的内存分为若干不同的数据区域，各有各的用途以及生命周期，有些是随着虚拟机进程的启动而存在，有些则以来线程的启动和结束而建立和销毁。
![运行时数据区域图示][1]
下面一一介绍。
### **一、线程隔离的数据区域（图中白色模块）**
这部分几个数据区域的生命周期都是和线程相同的。
#### 1.程序计数器（Program Counter Register）
一块较小的内存，可以看做是当前线程所执行的字节码的行号指示器，虚拟机的概念模型中，字节码解释器工作时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，每条线程都有一个独立的程序计数器，这样才能保证在多线程切换过程中切换后能够恢复到正确的执行位置。执行Java方法这个计数器才有值，如果执行的是一个Native方法，那这个计数器是空的（Undefined)。
注：Native方法，即本地方法，关于它的定义和用途参见这个——[Native方法简介][2]
#### 2.Java虚拟机栈（Java Stack)
其实就是很多书上说的栈内存和堆内存之中的栈内存。每个方法在执行时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接和方法出口等信息。每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程
局部变量表存放了编译器可知的各种基本数据类型、对象引用（不是对象）和retrunAddress类型。
#### 3.本地方法栈（Native Method Stack)
虚拟机栈为执行Java方法服务，而本地方法栈为执行Native方法服务。
### 二、线程共享的数据区域（图中绿色模块）
这部分的数据区域是所有线程共享的区域。
#### 1.Java堆（Java Heap)
一般情况下，是虚拟机管理内存中最大的一块，用于**存放对象实例（自然也包括数据）**，注意前面局部变量表里面是对象引用，那个引用要指向这里的对象实例。这块是垃圾收集器管理的主要区域。可以物理上不连续，只要逻辑上连续即可。可以实现固定大小的，也可以可扩展，目前主流JVM都是按照可扩展来实现的。
垃圾收集器采用的基本都是分代收集算法，所以堆还可以细分为新生代和老年代，后面会详解。
#### 2.方法区（Method Area)
用于存储被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。虚拟机规范中把方法区描述为堆的一个逻辑部分，但是一般我们把它和Java堆进行区分。在实现上这块和堆一样不需要连续内存并且可选择固定或者可扩展，还可以选择不进行垃圾收集。这块的GC目标主要针对常量池的回收和对类型的卸载，但往往条件很苛刻。
#### 3.运行时常量池（Runtime Constant Pool)
这是属于方法区的一部分，Class文件中除了有类的版本信息、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中，另外翻译出来的直接引用也会存储在这个区域中。这个区域另外一个特点就是动态性，Java并不要求常量就一定要在编译期间才能产生，运行期间也可以在这个区域放入新的内容，String.intern()方法就是这个特性的应用。这块什么符号引用直接引用后面会介绍。先不急。
## **对象的创建、内存布局和访问定位**
### 一、对象的创建
这里讨论的对象创建先局限于普通Java对象而不包括数组和Class对象。
**首先进行类加载检查**
虚拟机遇到一个new指令时，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有要先进行类的加载过程，这块之前写过笔记进行过简介。后面会更详细的学习。
**接着为新生对象分配内存**
类加载完成之后就可以确定一个对象所需要的内存大小，虚拟机会在Java堆中分配相应大小的内存区域给新生的对象。常见的分配方式有两种：
#### 1.指针碰撞
当堆内存是规整的时候，用过的内存在一边，闲置的内存在另一边，中间有一个指针作为分界点的指示器，那么分配内存就是把指针向闲置空间一侧挪动相应对象大小的距离就可以了。
#### 2.空闲列表
如果堆内存不是绝对规整而是用过和没用的内存相互交错，就无法进行指针碰撞了，这时候虚拟机需要维护一个列表，记录那些内存时可用的，分配时候从列表找一块足够的内存分配给新生对象并且更新列表上的记录。
另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。详见P45。
**接着虚拟机将分配到的内存空间都初始化为零值（不包括对象头）**
这一操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用。程序可以访问到这些字段对应数据类型的零值。
**接着对这个对象进行必要的设置**
例如这个对象是哪个类的实例、如何找到类的元数据信息、对象的hashCode，对象的GC分代年龄等信息，都存放在对象头（Object Header）中。
**最后执行<init>方法**
实质上一个对象从内存分配到属性设置已经基本创建完成了，最后的<init>方法完成的工作是把对象按照程序员的医院进行初始化，即那些字段将不仅仅是默认的零值，会根据赋的初值进行再次赋值。
### 二、对象的内存布局
创建了对象我们来了解一下一个对象区域内部的布局。可以分为三块区域：
#### 1.对象头（Object Header）
有两部分，第一部分存储对象自身的运行时数据，包括对象的hashCode，对象的GC分代年龄、线程持有的锁等信息，第二部分是类型指针，即指向它的类的元数据的指针，JVM通过它来确定这个对象是哪个类的实例以及获取它的元数据信息。但这部分不一定有，后面会讲解。如果对象是Java数组的话，对象头中还必须有一块用于记录数组长度的数据（普通对象的元数据可以确定对象的大小，但是数组的元数据中没有数组大小相关的内容）。
#### 2.实例数据部分（Instance Data)
这部分是对象真正存储的有效信息，即在程序代码中定义的各种类型的字段内容，包括在父类中继承的和在子类中定义的。
#### 3.对齐填充（Padding)
这部分并不是必须的，仅仅起占位符的作用，例如，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也即是对象的大小必须的8字节的整数倍，对象头本来就是8的整数倍，实例数据部分没有补齐8的倍数字节时候就需要这部分来补齐。
### 三、对象的访问定位
我们通过栈中的reference类型对象引用来定位、访问堆中对象实例。虚拟机实现主要有以下两种方式：
#### 1.句柄访问
Java堆中划分为句柄池和实例池，reference指向的是句柄池中对象的句柄地址，句柄中则包含了对象类型数据的指针和对象实例数据的指针，前者指向方法区该对象对应的类型数据，后者指向Java堆中实例池的对象实例数据。![此处输入图片的描述][3]
#### 2.直接指针访问
reference直接存储对象地址，对象中存储所有的实例数据和对象类型数据的指针，这个指针指向方法区的该对象对应的的类型数据。![此处输入图片的描述][4]

两种方式各有优势,句柄访问在对象被移动（这在GC中很常见）时候reference本身一直指向句柄，只会改变局并重实例数据指针，而直接指针访问的优势在于速度快，节省了一次指针定位的时间开销吗，但是对象移动时候，reference的值汇编。

  [1]: http://images.blogjava.net/blogjava_net/nkjava/jvmstructure.png
  [2]: https://zhidao.baidu.com/question/373430965404002844.html
  [3]: https://upload-images.jianshu.io/upload_images/2510824-4585f4452832b911.png?imageMogr2/auto-orient/
  [4]: https://upload-images.jianshu.io/upload_images/2510824-c24d5137f15387e6.png?imageMogr2/auto-orient/